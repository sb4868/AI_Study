'''
### numpy 활용 ###

1. vector / matrix 생성

2. 행렬 곱 (dot product)

3. broadcast

4. index / slice / iterator

5. concatenate

6. useful function (loadtxt(), rand(), argmax(), ...)

'''


'''1. vector / matrix 생성 '''

#============================================================================================================================#
### numpy 호출 ###

import numpy as np
#============================================================================================================================#


#============================================================================================================================#
### 벡터 생성 ###

A = np.array([1, 2, 3])
B = np.array([4, 5, 6])

# 벡터 A, B 출력
print('A :', A, 'B :', B)

# 벡터 A, B 형상 출력
print('A.shape :', A.shape, 'B.shape :', B.shape)

# 벡터 A, B 차원 출력
print('A.ndim :', A.ndim, 'B.ndim :', B.ndim)
#============================================================================================================================#
print("\n")

#============================================================================================================================#
### 벡터 산술연산 ###

# 벡터 산술 연산
print("A + B =", A + B)
print("A - B =", A - B)
print("A * B =", A * B)
print("A / B =", A / B)

# -> 벡터간 산술연산은 벡터의 각각의 원소에 대해서 연산이 진행된다.
#============================================================================================================================#
print("\n")

#============================================================================================================================#
### 행렬 생성 ###

A = np.array([[1,2,3],[4,5,6]])
B = np.array([[-1,-2,-3],[-4,-5,-6]])

# 행렬 A, B 출력
print('==Matrix A==\n', A)
print('==Matrix B==\n', B)

# 행렬 A, B 형상 출력
print('A.shape :', A.shape, 'B.shape :', B.shape)

# 행렬 A, B 차원 출력
print('A.ndim :', A.ndim, 'B.ndim :', B.ndim)
#============================================================================================================================#
print("\n")

#============================================================================================================================#
### 형 변환 ###
# C = np.array([[1],[2],[3]]) => 행렬
# C = np.array([1,2,3]) => 벡터
# vector를 atrix로 변경하거나 matrix를 다른 형상의 atrix로 변경하기 위해 reshape 사용

# vector 생성
C = np.array([[1],[2],[3]])

# vector C 형상 출력
print('C.shape :', C.shape)

# vector C 를 (1, 3) 행렬로 형 변환
C = C.reshape(1, 3)

print("C.shape :", C.shape)
print(C)

# data type 변환
# 정수형으로 저장했지만, data type을 float(64bit)로 변형 -> 실수 연산이 가능
A = np.array([1, 2, 3], dtype = np.float64)
A += 0.5
print(A)
#============================================================================================================================#






'''2. 행렬 곱 (dot product)'''

#============================================================================================================================#
### 행렬 곱 (dot product) ###
A = np.array([[1,2,3],[4,5,6]])           # 2 * 3 행렬
B = np.array([[-1,-2],[-3,-4],[-5,-6]])  # 3 * 2 행렬

# 행렬 A, B의 dot product
C = np.dot(A, B)

# matrix A, B 형상 출력
print('A.shape :', A.shape, 'B.shape :', B.shape)
print('C.shape :', C.shape)
print(C)
#============================================================================================================================#






'''3. Broadcast'''

#============================================================================================================================#
### numpy broadcast ###
# >> 크기가 다른 두 행렬간에도 사칙연산을 할 수 있도록 도와주는 라이브러리
# >>> 차원이 작은 쪽의 크기를 큰 쪽에 맞춘 후에 계산 -> 기존의 숫자를 반복적인 행단위로 채워놓는다. 

A = np.array([[1,2], [3,4]]) # 2*2 행렬
B = 5                        # 상수
print(A, '+', B ,'\n=', A + B)
print("")
C = np.array([[1,2], [3,4]]) # 2*2 행렬
D = np.array([4, 5])         # 1*2 행렬
print(C, '+', D ,'\n=',C + D)
#============================================================================================================================#
print("\n")

#============================================================================================================================#
### 전치행렬 (transpose) ###

A = np.array([[1,2],[3,4],[5,6]])
B = A.T
print('A.shape :', A.shape, 'B.shape :', B.shape)
print(A)
print(B)

print("")

C = np.array([1,2,3,4,5]) # C, D 는 벡터 => 벡터는 transpose 적용 안됨
D = C.T
E = C.reshape(1, 5)       # E, F 는 행렬
F = E.T
print('C.shape :', C.shape, 'D.shape :', D.shape)
print('E.shape :', E.shape, 'F.shape :', F.shape)
print(F)
#============================================================================================================================#






'''4. index / slice / iterator'''

#============================================================================================================================#
# 행렬 원소는 리스트 처럼 인덱싱 / 슬라이싱 모두 사용가능 하다.

A = np.array([10,20,30,40,50,60]).reshape(3,2)
print('A.shape :', A.shape)
print(A)
#============================================================================================================================#
print("\n")

#============================================================================================================================#
### 인덱싱 ###

print("A[0,0] :",A[0,0], ", A[0][0] :",A[0][0])
print("A[2,1] :",A[0,0], ", A[2][1] :",A[2][1])
#============================================================================================================================#
print("\n")

#============================================================================================================================#
### 슬라이싱 ###

print("A[0:-1, 1:2] :",A[0:-1, 1:2])

print("A[:,0] :", A[:,0])
print("A[:,:] :", A[:,:])
#============================================================================================================================#
print("\n")

#============================================================================================================================#
### iterator ###
# >> 행렬의 모든 원소에 접근해야 하는 경우 iterator 사용

A = np.array([[10, 20, 30, 40], [50, 60, 70, 80]])

print(A, "\n")
print('A.shape :', A.shape)

# 행렬 A 의 iterator 생성  => lost function을 구할 때 쓰인다.
it = np.nditer(A, flags=['multi_index'], op_flags=['readwrite'])

while not it.finished:
    idx = it.multi_index
    print("current value =>", A[idx])
    it.iternext()
#============================================================================================================================#






'''5. concatenate'''
'''
행렬에 행또는 열을 추가하기 위한 메서드
 -> 머신러닝의 회귀 코드 구현시 가중치와 바이어스를 별도로 구분하지 않고 하나의 행렬로 취급하기 위한 프로그래밍 구현 기술
'''
#============================================================================================================================#
# 행렬에 열과 행 추가
A = np.array([[10, 20, 30],[40, 50, 60]])
print(A)

# A matrix에 행(row) 추가할 행렬, 1행 3렬로 reshape
# 행을 추가하기 때문에 우선 열을 3열로 만들어야 함
row_add = np.array([70, 80, 90]).reshape(1, 3)

# A matrix에 열(column) 추가할 행렬, 2행 1열ㄹ로 reshape
# 열을 추가하기 때문에 우선 행을 2행으로 만들어야 함
column_add = np.array([1000,2000]).reshape(2, 1)

# numpy.concatenate 에서 axis = 1 열(column) 기준
# B 행렬에 column_add 행렬 추가
B = np.concatenate((A, row_add), axis=0)
print(B)

# numpy.concatenate 에서 axis = 1 열(column) 기준
# B 행렬에 column_add 행렬 추가
C = np.concatenate((A, column_add), axis=1)

print(C)
#============================================================================================================================#






'''6. useful function (loadtxt(), rand(), argmax(), ...)'''

#============================================================================================================================#
### load text ###
# seperator 로 구분된 파일에서 데이터를 읽기 위한 메서드
# load text 의 return값은 행렬

loaded_data = np.loadtxt('./data_01.csv', delimiter=',', dtype=np.float32)

x_data = loaded_data[ :, 0:-1]
y_data = loaded_data[ :, [-1]]

# 데이터 차원 및 shape 확인
print("x_data.ndim :",x_data.ndim, ", x_data.shape :",x_data.shape)
print("y_data.ndim :",y_data.ndim, ", y_data.shape :",y_data.shape)
print(x_data)
print(y_data)
#============================================================================================================================#
print("\n")

#============================================================================================================================#
### 0 ~ 1 사이의 random number 생성 ###

random_num1 = np.random.rand(3)
random_num2 = np.random.rand(1, 3)
random_num3 = np.random.rand(3, 1)

print("random_num1 :", random_num1, ", random_num1.shape :", random_num1.shape)
print("random_num2 :", random_num2, ", random_num2.shape :", random_num2.shape)
print("random_num3 :", random_num3, ", random_num3.shape :", random_num3.shape)
#============================================================================================================================#
print("\n")

#============================================================================================================================#
### sum, exp, log, max, min, argmax, argmin, ones, zeros ###

X = np.array([2, 4, 6, 8])

print("np.sum(X) :", np.sum(X))        # 벡터의 모든 원소의 합
print("np.exp(X) :", np.exp(X))        # 벡터의 모든 원소에 exponential을 취함
print("np.log(X) :", np.log(X))        # 벡터의 모든 원소에 log를 취함

print("np.max(X) :", np.max(X))        # 모든 벡터 원소 중 최대값 return
print("np.min(X) :", np.min(X))        # 모든 벡터 원소 중 최소값 return
print("np.argmax(X) :", np.argmax(X))  # 최대값을 갖는 원소의 index를 return 
print("np.argmin(X) :", np.argmin(X))  # 최소값을 갖는 원소의 index를 return

X = np.array([[2, 4, 6], [1, 2, 3], [0, 5, 8]])
# axis = 0 : column 기준
# axis = 1 : row 기준
print("np.max(X) :", np.max(X, axis = 0))         
print("np.min(X) :", np.min(X, axis = 0))         
print("np.max(X) :", np.max(X, axis = 1))         
print("np.min(X) :", np.min(X, axis = 1))         
print("np.argmax(X) :", np.argmax(X, axis = 0))   
print("np.argmin(X) :", np.argmin(X, axis = 0))   
print("np.argmax(X) :", np.argmax(X, axis = 1))   
print("np.argmin(X) :", np.argmin(X, axis = 1))   

A = np.ones([3, 3])
print("A.shape :", A.shape, ", A :", A)
B = np.zeros([3, 2])
print("B.shape :", B.shape, ", B :", B)
#============================================================================================================================#
print("\n")

#============================================================================================================================#
### matplotlib###
import matplotlib.pyplot as plt

# 주피터 노트북을 사용하는 경우 노트북 내부에 그림 표시
%matplotlib inline

# scatter plot
x_data = np.random.rand(100)
y_data = np.random.rand(100)

plt.title('scatter plot')                          # plot title
plt.grid()                                         # 보조선 생성
plt.scatter(x_data, y_data, color='b', marker='o') # 그래프 종류
plt.show()                                         # 화면에 출력

# line plot
x_data = [ x for x in range(-5, 5)]
y_data = [ y*y for y in range(-5, 5)]

plt.title('line plot')
plt.grid()
plt.plot(x_data, y_data, color = 'b')
plt.show()

x_data = [ -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
y_data = [6, -13, 0, 3, 6, -1, -5, -7, 1, 8, 7, 12, 13]
plt.title('line plot')
plt.grid()
plt.plot(x_data, y_data, color = 'b')
plt.show()
#============================================================================================================================#
